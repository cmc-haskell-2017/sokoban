<!-- Переименовал в TODO.md (@orchaton) -->
<!-- # Это я такой умник решил сделать нам аналог ЖИРЫ в виде текстового файла
Поэтому теперь будем ставить себе таски прямо тут
Таск получает название SOK-###:$$$$$$$$$$$$$, где символы решетки на номер таска, а после двоеточия едет краткое его описание
Если ты берешь таск на себя, то отметь его, как свой, а когда сделаешь, добавь ветку, на которой рабочий код
Ветки предлагаю называть идентификатором задачи
Выполненные задачи помечайте звездочкой в начале

 -->
# Сущности:
* Window - всеобъемлющий тип. Может быть игровым полем, либо меню пользователя
* Interface - Меню пользователя
* World a.k.a (IO GameBox). Тоже поле игры, только при считывание из файла от монады IO невозможно по человечески избавиться.

# Handle.hs (Обработчик событий)
Предоставляет наружу функцию: `handle :: Event -> Window -> Window` -- основной обработчик событий.

__ВАЖНО!__ События обрабатываются над окном, но в самом окне могут быть разные сущности (например, игровое поле `World` или `Interface` меню пользователя) --> это нужно предусмотреть в проектировании типа `Window`.

Задача Handle.hs распаковать (IO GameBox) в GameBox и вызвать на нем метод (move MoveLeft gb), (move MoveRight gb), (move MoveUp gb), (move MovesDown gb) соответственно.

MoveLeft, MoveRight, MoveUp, MoveDown -- объявлены в Types.hs отдельным типом Movement.

Аналогично над модулем Interface.

# Interface.hs (Меню пользователя)
То, с чего начинается игра. Что-то типа 'Start Game', 'Scores', 'Load Labirint' и тому подобное.
'Start Game' -> Запуск генерации лабиринта, Изменение полей структуры окна (Window)
'Scores' -> Поход в БД (на самом деле файл, а может и нет), изменение внутренней полей структуры Interface! __(НЕ Window!)__

Для Interface нужен свой рендеринг. Лучше реализовать в том же модуле __Render.hs__ Он векторный, и простой.